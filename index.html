<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta propery="og:url" content="https://outsidecontextproblem.com"/>
    <meta propery="og:type" content="website"/>
    <meta propery="og:title" content="outside context problem"/>
    <meta propery="og:description" content="Stevo's rambings"/>
    <meta propery="og:image" content="https://www.outsidecontextproblem.com/logo.png"/>
    <title>Stevo's Blog</title>
    <link rel="stylesheet" type="text/css" href="default.css"/>
    <link rel="icon" type="image/x-icon" href="logo.png">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-H7QJF2MQ5R"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() { dataLayer.push(arguments); }

        gtag('js', new Date());

        gtag('config', 'G-H7QJF2MQ5R');
    </script>
</head>
<body>
<div class="header">
    <span>Outside</span> <span>Context</span> <span>Problem</span>
    <a href="contents.html">&#x2630;</a>
</div>
<div class="post">
    <div class="title">
        <a id="links-or-tldr" href="#links-or-tldr">Links or, TL;DR</a>
    </div>
    <hr/>
    <div class="content">
        <p>
            If you don't want to wade through all my ramblings in this series of posts, the meat is here:
            <ul>
                <li>
                    <a href="https://adventofcode.com/2021/events">Puzzles</a>.
                </li>
                <li>
                    <a href="https://github.com/stevehjohn/AoC">Source code</a>.
                </li>
                <li>
                    <a href="https://www.youtube.com/playlist?list=PLBtwzTaAY-IWq6Mi1nvwsphMTw-HU13eM">Visualisations</a>.
                </li>
            </ul>
        </p>
        <img src="logo.png" class="fox"/>
    </div>
</div>
<div class="post">
    <div class="title">
        <a id="engaged" href="#engaged">Engaged</a>
    </div>
    <hr/>
    <div class="content">
        <p>
            So, having discovered the <a href="https://adventofcode.com/">Advent of Code</a> site and being intrigued by the way the puzzles were framed, I found the early ones a nice distraction from my usual "business" coding.
            They seemed to go back to computing basics, and a lot of things that an everyday web developer or back end programmer just doesn't need to think about.
        </p>
        <p>
            It took me back to the things I enjoyed about coding before bills, mortgages, taxes etc... entered into my life!
        </p>
        <p>
            Also, I'm slightly ashamed to admit, I think the fact that there was a leaderboard may have stirred up a latent competitive spirit.
        </p>
        <p>
            Once I'd done the first couple of puzzles, I started to get it. <a href="https://twitter.com/ericwastl">Eric Wastl</a> obviously puts a large amount of effort into thinking through his puzzles, providing unique input
            for each participant, but also in framing the puzzle with a fun, Christmas themed story.
        </p>
        <p>
            I also realised that I didn't really want to create one or two new console applications every day to participate in this, so a framework was required...
        </p>
        <img src="logo.png" class="fox"/>
    </div>
</div>
<div class="post">
    <div class="title">
        <a id="reflection" href="#reflection">Reflection</a>
    </div>
    <hr/>
    <div class="content">
        <p>
            The obvious route (to me, anyway) was to create a base class that puzzle solutions could inherit from. Then, I could have a <a href="https://en.wikipedia.org/wiki/Console_application">console</a> application that would scan
            the assembly using <a href="https://en.wikipedia.org/wiki/Reflective_programming">reflection</a> for concrete implementations of this class, execute them, and check the answer against a text file.
        </p>
        <p>So, this is the base class I came up with.</p>
        <pre>
public abstract class Solution
{
    protected string[] Input;

    public abstract string Description { get; }

    protected Solution()
    {
        var nameSpace = GetType().Namespace ?? string.Empty;

        var parts = nameSpace.Split('.');

        var path = parts.Skip(2).Select(s => s.Replace("_", string.Empty)).ToArray();

        Input = File.ReadAllLines($"{string.Join(Path.DirectorySeparatorChar, path)}{Path.DirectorySeparatorChar}input.txt");
    }

    public abstract string GetAnswer();
}
</pre>
        <p>
            The constructor loads the puzzle input file and makes it available to subclasses via the <span class="inline">Input</span> field. The <span class="inline">Description</span> property is for inheritors to implement to describe the puzzle they are solving. Lastly, surprise surprise,
            <span class="inline">GetAnswer</span> should be used by implementors (i.e. <a href="https://twitter.com/SteveHuwJohn">me</a>) to solve the puzzle and return the answer as a string. So far, <a href="https://adventofcode.com/">AoC</a> had only required integer answers but, I've been around the block and kept my options open.
        </p>
        <p>
            So, apart from some timing code (competitive, see?) and some other things added later, the main console app was:
        </p>
        <pre>        
var solutions = Assembly.GetExecutingAssembly()
                        .GetTypes()
                        .Where(t => t.IsSubclassOf(typeof(Solution)) && ! t.IsAbstract)
                        .OrderBy(t => t.Namespace)
                        .ThenBy(t => t.Name);

foreach (var solution in solutions)
{
    var instance = Activator.CreateInstance(solution) as Solution;
    
    var answer = instance.GetAnswer();

    CheckAnswer(instance.GetType(), answer);
}
</pre>
        <p>
            Where <span class="inline">CheckAnswer</span> would look in a text file for a line formatted <span class="inline">2021.5.1: abc</span> meaning that the answer to 2021, December the 5th, part one was <span class="inline">abc</span>.
            If they didn't match, it will throw an exception.
        </p>
        <p>
            Obviously, when embarking on each puzzle I didn't know the answer. Once I had the correct answer, I added it to the text file.
            The idea behind this mechanism was to prevent regressions as I anticipated code sharing somewhere down the line.
        </p>
        <p>
            So, my framework was largely in place, I was having fun and... possibly getting a bit cocky.
        </p>
        <img src="logo.png" class="fox"/>
    </div>
</div>
<div class="post">
    <div class="title">
        <a id="plain-sailing" href="#plain-sailing">Plain Sailing</a>
    </div>
    <hr/>
    <div class="content">
        <p>
            So, now with the framework in place, I could take some time out every day to do a bit of <a href="https://en.wikipedia.org/wiki/Code_golf">code golf</a> of sorts (I wasn't going for the shortest solution... fastest... maybe.)
            Great fun, good mental exercise and, frankly a bit of a change from <a href="https://en.wikipedia.org/wiki/Business_logic">business logic</a>.
        </p>
        <p>
            I saw how quickly my solutions were executing (see console output below) and set myself a goal of having all solutions for the season execute in under one second, combined.
        </p>
        <pre>
2021  1.1: 1466                           0ms     Depth scan
2021  1.2: 1491                           1ms     
2021  2.1: 1746616                        0ms     Navigate forward
2021  2.2: 1741971043                     0ms     
2021  3.1: 2743844                        0ms     Power consumption
2021  3.2: 6677951                        0ms     
2021  4.1: 32844                          4ms     Squid bingo
2021  4.2: 4920                           3ms     
2021  5.1: 7297                           17ms    Hydrothermal vents
2021  5.2: 21038                          20ms    
2021  6.1: 391888                         0ms     Lanternfish parthenogenesis
2021  6.2: 1754597645339                  0ms     
2021  7.1: 348664                         0ms     Crab submarines
2021  7.2: 100220525                      0ms     
2021  7.X: Ceci n'est pas une intcode...  0ms     Easter egg (2019 CPU used)
2021  8.1: 294                            0ms     Old school displays
2021  8.2: 973292                         3ms     
2021  9.1: 498                            0ms     Lava level
2021  9.2: 1071000                        4ms     
2021 10.1: 370407                         2ms     Esoteric language parser
2021 10.2: 3249889609                     1ms     
2021 11.1: 1755                           3ms     Flashers
2021 11.2: 212                            6ms     
</pre>
        <p>
            I really can't heap enough praise on <a href="https://twitter.com/ericwastl">Eric Wastl</a> for the effort put into these puzzles, also the colleague who brought this to my attention,
            and the other colleagues who participated in this event. I'm an interminable nerd and this is completely my idea of fun.
        </p>
        <img src="logo.png" class="fox"/>
    </div>
</div>
<div class="post">
    <div class="title">
        <a id="multithreading" href="#multithreading">Multithreading</a>
    </div>
    <hr/>
    <div class="content">
        <p>
            In the chat around this challenge, another colleague mentioned to me that there were previous years (which I hadn't noticed), and one which required you to iterate on a CPU emulator.
            This sounded really interesting to me as it reminded me of some homework I did for a friend who studied computer science at <a href="https://en.wikipedia.org/wiki/Department_of_Computer_Science,_University_of_Bristol">university</a>
            (and who went on to do something completely unrelated to CS.)
        </p>
        <p>
            So, the multithreading begins.
        </p>
        <p>
            It was the 2019 year that this particular challenge existed, so I started doing that one at the same time... why not?
        </p>
        <img src="logo.png" class="fox"/>
    </div>
</div>
<div class="post">
    <div class="title">
        <a id="oh-thats-why" href="#oh-thats-why">Oh, That's Why...</a>
    </div>
    <hr/>
    <div class="content">
        <p>
            I'm not ashamed to admit to a level of OCD. In fact, it's probably what gives me the attention to detail and fastidiousness to be good at my job. It can also be a <a href="https://en.wiktionary.org/wiki/pain_in_the_arse">PITA</a>.
        </p>
        <p>
            Having folders in my solution explorer jumping from 2019 to 2021 bothered me. More than it should. First world problems, I know, but it probably drove me to solve the puzzles faster.
        </p>
        <p>
            And to not embark on another year's ones until the previous ones were completed.
        </p>
        <img src="logo.png" class="fox"/>
    </div>
</div>
<div class="post">
    <div class="title">
        <a id="blue-skies" href="#blue-skies">Blue Skies</a>
    </div>
    <hr/>
    <div class="content">
        <p>
            Anyway, this is going well, I'm having fun with the puzzles and chatting with colleagues in the AoC Slack channel.
        </p>
        <p>
            Plain sailing, <a href="https://www.youtube.com/watch?v=DBT7nUxJpC4">blue skies</a>... wasn't struggling with any of the puzzles. May have been neglecting some downtime from the computer though, but hey, if it's fun, it's fun right?
        </p>
        <p>
            Really enjoying the puzzles from both years (but still itching to finish them, so I could fill in the missing 2020 gap.)
        </p>
        <p>
            Then <a href="https://adventofcode.com/2021/day/15">2021.15</a> dropped.
        </p>
        <p>
            I am writing this a couple of months after the fact, so my memory isn't razor sharp, but I really struggled with this one even though I thought I knew what I needed to do.
        </p>
        <p>
            This is where I had to start using <a href="https://www.youtube.com/playlist?list=PLBtwzTaAY-IWq6Mi1nvwsphMTw-HU13eM">visualisations</a> that would become more sophisticated as I progressed through the puzzles.
        </p>
        <p>
            I started with these visualisations to help me reason about the problem:
            <ul>
                <li>
                    <a href="https://www.youtube.com/watch?v=ezjp8jL6hSI">Small data set.</a>
                </li>
            </ul>
            <ul>
                <li>
                    <a href="https://www.youtube.com/watch?v=EcPOB13PyMM">Large data set.</a>
                </li>
            </ul>
            But as you can see, especially from the second one, my approach was not going to finish any time soon.
        </p>
        <p>
            Also, as I had set myself a performance target, I really didn't want the visualisations to impact the puzzle when not required. This ended up with a lot of conditional compilation, which I wasn't over the moon about.
        </p>
        <pre>
protected int Solve()
{
    var queue = new PriorityQueue&lt;Node, int&gt;();

    queue.Enqueue(_rootNode, int.MaxValue);

    var costs = new Dictionary&lt;int, int&gt;
                {
                    { 0, 0 }
                };
<span class="fade">
#if DUMP && DEBUG
    Console.Clear();

    Console.CursorVisible = false;

    Console.ForegroundColor = ConsoleColor.DarkGray;
#endif
</span>
    while (queue.Count > 0)
    {
        var node = queue.Dequeue();
<span class="fade">
#if DUMP && DEBUG
        Console.CursorLeft = node.Position.X;

        Console.CursorTop = node.Position.Y;

        Console.Write('█');
#endif
</span>
        if (node.Position.X == _width - 1 && node.Position.Y == _height - 1)
        {
            break;
        }

        foreach (var neighbor in node.Neighbors)
        {
            var cost = costs[node.Position.X + node.Position.Y * _width] + neighbor.Value;

            if (! costs.TryGetValue(neighbor.Position.X + neighbor.Position.Y * _width, out var nextCost) || cost < nextCost)
            {
                costs[neighbor.Position.X + neighbor.Position.Y * _width] = cost;

                queue.Enqueue(neighbor, cost);
            }
        }
<span class="fade">
#if DUMP && DEBUG
        DrawPath(costs);
#endif</span>
    }
}
</pre>
        <p>
            I would solve the conditional compilation issue later on. For now I was focused on getting the puzzles completed.
        </p>
        <p>
            After a lot of wrong turns, a geeky friend of mine told me to look up <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra's Algorithm</a> which I duly implemented (code above.)
        </p>
        <p>
            This was a bit of a revelation and worked a treat as you can see from <a href="https://www.youtube.com/watch?v=BVissVcc_EY">this visualisation</a>. Without outputting to the console, the puzzle executes in about 4ms.
        </p>
        <img src="logo.png" class="fox"/>
    </div>
</div>
<div class="post">
    <div class="title">
        <a id="a-side-note-on-hardware" href="#a-side-note-on-hardware">A Side Note on Hardware</a>
    </div>
    <hr/>
    <div class="content">
        <p>
            I have been working on these puzzles on my personal machine which is a high spec 16" 2020 Intel MacBook Pro. I have it dual booted between macOS and Windows so I can switch to whichever suits my current task.
            Usually, Windows for coding and <a href="https://rtypefinal2.com/">gaming</a> and macOS for playing with <a href="https://soundcloud.com/s-h-john/game-of-thrones-metal-wip">music creation</a>.
        </p>
        <p>
            Now that dotnet is cross platform friendly, I could run the AoC project in <a href="https://visualstudio.microsoft.com/vs/community/">Visual Studio</a> in Windows, or <a href="https://www.jetbrains.com/rider/">Rider</a> on macOS.
        </p>
        <p>
            Running the project in either environment produced no discernible difference in performance, so it seems the choice of OS doesn't make much difference to dotnet's use of the bare metal.
        </p>
        <p>
            So, the Intel MacBook specs that matter are:
        </p>
        <pre>
Processor:          Intel Core i9-9980HK
Base Speed:         2.40GHz
Cores:              8
Logical Processors: 16
RAM:                32GB
</pre>
        <p>
            I recently got a work laptop refresh to a 13" M1 MacBook Pro with the following specs:
        </p>
        <pre>
Processor:          Apple M1
Base Speed:         <a href="https://www.youtube.com/watch?v=7wbie3lcjiQ">Nobody Knows</a>
Cores:              8 (4 performance, 4 efficiency)
RAM:                16GB
</pre>
        <p>
            I thought it would be interesting, given Apple's bold claims, to see how my code performed on this machine.
        </p>
        <p>
            Wow.
        </p>
        <p>Execution times for all 343 (7 years &#215; 49, since Christmas day doesn't have a part 2) puzzles:</p>
        <pre>
Intel MacBook Pro: 131,634ms
<span class="inline">M1 MacBook Pro:    113,161ms</span>
</pre>
        <p>
            That's a <span class="inline">14%</span> reduction in execution time on a MacBook that was probably around half the cost of my personal one. Seems Apple may have some substance behind their claims.
        </p>
        <img src="logo.png" class="fox"/>
    </div>
</div>
<div class="post">
    <div class="title">
        <a id="multithreading-continued" href="#multithreading-continued">Multithreading Continued...</a>
    </div>
    <hr/>
    <div class="content">
        <p>
            As I mentioned, a colleague recommended the 2019 series of puzzles because of the CPU emulation aspect. I'll go into that in a later entry.
        </p>
        <p>
            A puzzle from 2019 that I particularly enjoyed was <a href="https://adventofcode.com/2019/day/18">2019.18</a>. A very interesting challenge.
        </p>
        <p>
            Essentially, you are given a maze as input. The interesting aspect of this puzzle though is that there are <a href="https://www.youtube.com/watch?v=9-clrKOp5Co">upper- and lower-case</a> characters strewn throughout the maze.
            The uppercase characters represent doors, while lowercase ones represent keys that will open the corresponding door.
        </p>
        <p>
            Your job is to find the shortest path through the maze that unlocks all the doors. I was very intrigued with this one.
        </p>
        <p>
            Here is a visualisation of how I solved the problem, and I'll explain my approach below.
        </p>
        <p>
            <ul>
                <li><a href="https://www.youtube.com/watch?v=pHIyrLsMJns">Advent of Code 2019 Day 18 Part 1</a>.</li>
            </ul>
        </p>
        <p>
            So, this is not necessarily a textbook CS approach to it, but it is how I decided to solve it (no doubt biased by my <a href="#the-beginning">maze solving</a> adventures as a child.)
        </p>
        <p>
            I approached the problem in two phases essentially.
            <ul>
                <li>Find the distances between all the doors, keys and the start point (start - 2:23).</li>
                <li>Find the shortest path that opens every door given what was discovered in phase one.</li>
            </ul>
        </p>
        <p>
            Phase 2 is not really engaging to visualise, so the remainder of the video (2:23 - end) is just the execution of the path that the code found.
        </p>
        <p>
            While visualising using the console as in this video was a useful aid, I wish I'd switched to using <a href="https://www.monogame.net/">MonoGame</a> earlier for more performant and visually interesting illustrations.
            More on that in a later post I expect.
        </p>
        <h2>Phase 1</h2>
        <p>
            As you may be able to discern in the video, I start a "bot" at each significant point on the map (keys, doors and start point.)
        </p>
        <p>
            Each of these bots will then try and explore the entire map. They do this by splitting into copies of themselves whenever there is a choice of more than one way to go. Each copy retains the history of the bot that spawned them.
            While in the visualisation this may not look too efficient, it actually completes in ~200ms.
        </p>
        <p>
            The hardest problem I faced in this exploration phase was the centre of the map. The maze exploring bots were designed to split at junctions, which is fine. However, the center of the map was an open 3&#215;3 square.
            This caused a massive problem with any bots entering that area just splitting infinitely. I eventually solved this by ensuring each bot not only stores the important cells they had encountered, but their entire history of travel.
            This way, I could prevent a bot from spawning a copy to visit a cell that it had already been to.
        </p>
        <p>
            At the end of this phase, I now have a list of the routes between all significant points on the map.
        </p>
        <h2>Phase 2</h2>
        <p>
            To be continued... (mainly because it's late and there was actually <a href="https://github.com/stevehjohn/AoC/tree/master/AoC.Solutions/Solutions/2019/18">quite a lot of code</a> in my solution for this one which I need remind myself of how it works.)
        </p>
        <p>
            I kind of have a policy that code should mostly not need comments if it is well thought out, well structured, good variable names etc... but sometimes, I wish I'd left myself some comments.
        </p>
        <img src="logo.png" class="fox"/>
    </div>
</div>
<div class="post">
    <div class="title">
        <a id="many-worlds-interpretation-2019-18-continued" href="#many-worlds-interpretation-2019-18-continued">Many-Worlds Interpretation (2019.18) Continued</a>
    </div>
    <hr/>
    <div class="content">
        <p>
            I have coffee and have refamiliarised myself with my own code. Let's continue...
        </p>
        <p>
            So from phase 1 of the implementation, we now have a list of distances between the significant points on the map. I have these stored in a dictionary.
        </p>
        <pre>
Wz: 5
Yd: 7
Pr: 7
@e: 18
fx: 20
ay: 22
JK: 16
...
</pre>
        <p>
            Remember, uppercase letters are doors, lowercase letters are keys and the <span class="inline">@</span> symbol is the starting point in the maze. There are <span class="inline">1378</span> entries in the dictionary, the number
            of combinations of 2 of 53 (<span class="inline">a-z</span>, <span class="inline">A-Z</span>, <span class="inline">@</span>) characters.
            The number is simply the number of steps between the items in any orthogonal direction (up, down, left, right). So, in the above example, there are <span class="inline">5</span> steps between
            the door <span class="inline">W</span> and the key <span class="inline">z</span>.
        </p>
        <p>
            I also have a dictionary of doors between points:
        </p>
        <pre>
Bz: W
iu: N
Zm: K, J
Hr: P, V, I
...
</pre>
        <p>
            So, in the above example, to get to door <span class="inline">H</span> from key <span class="inline">r</span> (or vice-versa), you need to pass through doors <span class="inline">P</span>, <span class="inline">V</span> and <span class="inline">I</span>.
        </p>
        <p>
            I pass both of these into a <span class="inline">Graph</span> class which, unsurprisingly, constructs a graph of connected nodes from the first dictionary. At this point it just stores a reference to the doors dictionary, it is not
            included in the node graph.
        </p>
        <p>
            This <span class="inline">Graph</span> class is passed into a <span class="inline">GraphSolver</span> class. This class maintains a queue of <span class="inline">INodeWalkers</span> which, like the bots in the discovery phase,
            start at a point and split when reaching a junction. In this case though, we start with one at the maze start point. The queue is a <span class="inline">PriorityQueue</span> so nodes can be added with their distance as the priority,
            and shorter ones will be evaluated first.
        </p>
        <p>
            You may have noticed, this is essentially <a href="#blue-skies">Dijkstra's Algorithm</a> again to some extent. The reason for the extra layers of abstraction will become apparent when I cover part 2 of this puzzle.
        </p>
        <p>
            Given that the priority queue evaluates shortest distances first, as soon as an <span class="inline">INodeWalker</span> has visited every key, we can return the number of steps required and answer the puzzle.
            My implementation also returns the path taken, to make the visualisation possible.
        </p>
        <p>
            For part 1 of this puzzle, the <span class="inline">INodeWalker</span> implementation is (drum-roll) <span class="inline">NodeWalker</span>. As mentioned, this is essentially like the discovery bots from phase 1,
            but walks the graph constructed by the <span class="inline">Graph</span> class. It contains some additional logic to check whether a door that hasn't been unlocked exists between two nodes, but that's pretty much it.
        </p>
        <p>
            I hope I've explained my approach in an understandable manner. I think the <a href="https://github.com/stevehjohn/AoC/tree/master/AoC.Solutions/Solutions/2019/18">code</a> is quite clean and
            class responsibilities are well delineated. Feel free to provide any constructive <a href="contents.html#contact-details">feedback</a>.
        </p>
        <img src="logo.png" class="fox"/>
    </div>
</div>
<div class="post">
    <div class="title">
        <a id="many-worlds-interpretation-2019-18-part-2" href="#many-worlds-interpretation-2019-18-part-2">Many-Worlds Interpretation (2019.18) Part 2</a>
    </div>
    <hr/>
    <div class="content">
        <p>
            Part 2 of this puzzle ups the ante on the interest level...
        </p>
        <p>
            The map is to be modified so the centre 3&#215;3 square that gave me a headache in part one is to be closed off, dividing the maze into 4 separate parts with no path between them.
        </p>
        <p>
            You now have an actor in each quadrant and have to coordinate them to collect all the keys since a key for a door in one quadrant might be in a different quadrant. Interesting!
        </p>
        <p>
            Here is the visualisation for the solution to this problem.
        </p>
        <p>
            <ul>
                <li><a href="https://www.youtube.com/watch?v=tLmdPu_1zgY">Advent of Code 2019 Day 18 Part 2</a>.</li>
            </ul>
        </p>
        <p>
            Now, I think you'll see why the levels of abstraction over a simpler pathfinding algorithm were required.
        </p>
        <p>
            As in <a href="#multithreading-continued">part 1</a>, there is a discovery phase and then the solving phase. The discovery phase is pretty much the same, but there are four origins instead of one.
        </p>
        <p>
            We now create 4 instances of the <span class="inline">Graph</span> class (one for each quadrant) and pass them into the single <span class="inline">GraphSolver</span> class. The instance of <span class="inline">INodeWalker</span>
            is now <span class="inline">MultiGraphNodeWalker</span> and 4 of them are added to the initial queue, one for each actor's starting point.
        </p>
        <p>
            The <span class="inline">MultiGraphNodeWalker</span> is similar to the other "bots" described in the posts regarding this puzzle, except when it reaches a junction point it will spawn alternate "timelines" if you will.
            The alternate timelines (not sure this is the right phrase, but I'll run with it) allow the other actors to try out possible moves before the current actor makes its next move.
        </p>
        <p>
            This approach allows for actors to unlock doors for the other actors in different quadrants.
        </p>
        <p>
            I may have to revisit some of these posts as while my enthusiasm level is high, my energy levels are sometimes low (this is a side hobby to my full-time job). I feel I could explain some of my reasoning
            more clearly. Any <a href="contents.html#contact-details">feedback</a> on this would be appreciated.
        </p>
        <img src="logo.png" class="fox"/>
    </div>
</div>
<div class="post">
    <div class="title">
        <a id="drunken-rallying" href="#drunken-rallying">Drunken Rallying</a>
    </div>
    <hr/>
    <div class="content">
        <p>
            Context switch in our multithreaded process, back to 2021 from 2019.
        </p>
        <p>
            So, it's Saturday, December 18th. Can't really remember what I was up to, but an old friend phoned and he was up for a catch-up and some beer. This was around 8pm.
            I was dubious as from where he lives, he wouldn't get here until 10pm, but my arm was twisted.
        </p>
        <p>
            He turned up around 9:30pm which was a surprise because he's never early, and not a surprise because he, err, doesn't exactly hang around when driving.
        </p>
        <p>
            We started on the beers and indulged in some <a href="https://www.gtomega.co.uk/products/art-racing-cockpit">drunken rallying</a>.
        </p>
        <p>
            I think around 5am while it was his turn to race around the <a href="https://dirtgame.com/dirt5/news/blaze-a-trail">Norwegian countryside</a>, I remembered AoC would have unlocked for that day. Perfect opportunity to get in quick and
            score a higher position on the leaderboard.
        </p>
        <p>
            No chance, this one was a humdinger. Welcome to <a href="https://adventofcode.com/2021/day/19">2021.19</a>.
        </p>
        <p>
            Reading through the puzzle (even with my beer and rally addled brain), I thought how interesting this one was. Between turns on the driving rig I found myself pondering the possible solutions.
        </p>
        <p>
            The AoC description covers the puzzle in detail obviously, but the short version is:
            <ul>
                <li>
                    You have a bunch of scanners in the ocean.
                </li>
                <li>
                    These scanners report back to you a list of beacons they can detect within their sensor range.
                </li>
                <li>
                    The scanners report back the beacon locations relative to the scanner's own position.
                </li>
            </ul>
            And crucially...
            <ul>
                <li>
                    The scanner doesn't know which way it is facing (a bit like me that evening to be honest.)
                </li>
            </ul>
        </p>
        <p>
            That last point means you could have two scanners, in the exact same location, detecting exactly the same beacons, but reporting back two entirely different sets of coordinates.
        </p>
        <p>
            What followed was a mixture of drinking, rallying and me and my mate using the <a href="https://en.wikipedia.org/wiki/Right-hand_rule">right hand rule</a> a lot.
        </p>
        <p>
            Then we passed out.
        </p>
        <img src="logo.png" class="fox"/>
    </div>
</div>
<div class="post">
    <div class="title">
        <a id="the-morning-afternoon-after" href="#the-morning-afternoon-after">The <span class="strikethrough">Morning</span> Afternoon After</a>
    </div>
    <hr/>
    <div class="content">
        <p>
            Given a pretty much 12-hour beer and rally session, neither of us rose early the next day.
        </p>
        <p>
            Cue coffee, fry-up and hair of the dog (for me anyway, as I was already home and didn't have to drive anywhere.)
        </p>
        <p>
            Didn't progress much as I was just enjoying catching up with my old friend, but all good things come to an end (like weekends) and he had to go.
        </p>
        <p>
            So, on with the puzzle...
        </p>
        <p>
            This is one that I think would have really benefited from a visualisation to help me reason about it, but I hadn't yet progressed to using <a href="https://www.monogame.net/">MonoGame</a> yet, and there was no chance realistically of doing this in the console.
        </p>
        <p>
            There was a well <a href="https://en.wikipedia.org/wiki/Telegraphing_(sports)">telegraphed</a> clue in the puzzle though:
            <div class="quote">... such that there are at least 12 beacons that both scanners detect ...</div>
        </p>
        <p>
            I don't know whether there is a mathematical reason that 12 is the magic number, or whether that is just the way the puzzle was designed, and frankly I can't be arsed to find out, but it was a clue.
        </p>
        <p>
            After a while it dawned on me that I could use the distances of the beacons from the scanner to detect overlaps.
            It didn't need to be <a href="https://en.wikipedia.org/wiki/Euclidean_distance">Euclidian</a>, <a href="https://en.wikipedia.org/wiki/Taxicab_geometry">Manhattan</a> would work just fine.
        </p>
        <p>
            If two scanners had 12 or more beacons the same distance from itself, it's likely (turns out, definitely) they overlap.
        </p>
        <p>
            Simple enough. Go through each scanner's data, and calculate each beacon's distance from the scanner:
        </p>
        <p>
            <span class="inline">Math.Abs(scanner.X - beacon.X) + Math.Abs(scanner.Y - beacon.Y) + Math.Abs(scanner.Z - beacon.Z)</span>
        </p>
        <p>
            Then find which scanners have 12 or more common distances, and voilà, you know which scanners' ranges intersect each other.
        </p>
        <p>
            Okay, so what next?
        </p>
        <p>
            Part 1 expects the total number of beacons as the answer.
        </p>
        <p>
            Looking at my GitHub history, it took me a couple of days to realise this, but once you have the overlapping beacons it's quite simple. It is basically a <a href="https://en.wikipedia.org/wiki/Union_(set_theory)">union</a>
            of the distances.
        </p>
        <p>
            If scanner A sees 20 beacons and scanner B sees 18 beacons and 12 of them overlap, then there must be 26 unique beacons.
        </p>
        <p>
            Phew, part 1 done.
        </p>
        <p>
            What's part 2 asking? Let's see. Okay, seems reasonable...
        </p>
        <p>
            This turned out to be a descent into madness of sorts. I didn't end up solving it until January. And, it turns out, I was pretty close most of the time but for a one line bug. Fudge.
        </p>
        <img src="logo.png" class="fox"/>
    </div>
</div>
<!--<div class="post">
    <div class="title">
        <a id="" href="#"></a>
    </div>
    <hr/>
    <div class="content">
        <p>

        </p>
        <img src="logo.png" class="fox"/>
    </div>
</div>-->
</body>
</html>